
    def steps(self):
        """Yields steps for the current epoch."""
        self._current_step = 0
        # `self._inferred_steps` can be changed by `catch_stop_iteration`.
        while (self._inferred_steps is None or
           self._current_step < self._inferred_steps):
            if self._insufficient_data:  # Set by `catch_stop_iteration`.
                print('Insufficient data')
                break
            yield self._current_step
            self._current_step += 1
            
    @contextlib.contextmanager
    def catch_stop_iteration(self):
        """Catches errors when an iterator runs out of data."""
        try:
            yield

        except (StopIteration):
            if (#self._adapter.get_size() is None and 
                self._inferred_steps is None and
                self._current_step > 0):
                # The input passed by the user ran out of batches.
                # Now we know the cardinality of the input(dataset or generator).
                self._inferred_steps = self._current_step
            else:
                self._insufficient_data = True
                total_epochs = self._epochs - self._initial_epoch
                print('Insufficient data')

    @property
    def inferred_steps(self):
        """The inferred steps per epoch of the created `Dataset`.
        This will be `None` in the case where:
        (1) A `Dataset` of unknown cardinality was passed to the `DataHandler`, and
        (2) `steps_per_epoch` was not provided, and
        (3) The first epoch of iteration has not yet completed.
        Returns:
          The inferred steps per epoch of the created `Dataset`.
        """
        return self._inferred_steps
    
    def temperorily_set_emb_matrix(self, ent_emb, rel_emb):
        with self.backend as backend:
            backend.temperorily_set_emb_matrix(ent_emb, rel_emb)